WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT    = _{ "//" ~ (!"\n" ~ ANY)* }

// Numbers support both integers and floating-point
number = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT*)? }

// Strings are double-quoted (Note: AWK also supports single quotes, but we'll keep it simple)
string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Identifiers start with letter or underscore, contain alphanumeric or underscore
identifier    = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
member_access =  { "." ~ identifier }

type_expr    = { type_primary ~ array_suffix* }
type_primary = { identifier ~ type_args? }
type_args    = { "<" ~ type_expr ~ ("," ~ type_expr)* ~ ">" }
array_suffix = { "[]" }

// Arithmetic operators
add      = { "+" }
subtract = { "-" }
multiply = { "*" }
divide   = { "/" }
modulo   = { "%" }
power    = { "^" }

// Assignment operators
assign = { "=" }

// Comparison operators
eq = { "==" }
ne = { "!=" }
le = { "<=" }
// Must come before "<" to avoid tokenizing "<=" as "<" + "=" in the `infix_op` rule later
ge = { ">=" }
// Must come before ">" to avoid tokenizing ">=" as ">" + "=" in the `infix_op` rule later
lt = { "<" }
gt = { ">" }

// Logical operators
logical_and = { "&&" }
logical_or  = { "||" }
logical_not = { "!" }

param            =  { identifier ~ (":" ~ type_expr)? }
param_list       = _{ param ~ ("," ~ param)* }
function_literal =  { "fn" ~ "(" ~ param_list? ~ ")" ~ (":" ~ type_expr)? ~ block }

arg_list   = _{ expr ~ ("," ~ expr)* }
tuple_expr =  { "(" ~ expr ~ ("," ~ expr)+ ~ (",")? ~ ")" }

// Return statement
return_stmt = { "return" ~ expr? }

// Primary expressions (atoms that cannot be broken down further)
primary = _{
    number
  | string
  | function_literal
  | tuple_expr
  | block
  | identifier
  | "(" ~ expr ~ ")"
}

call_suffix =  { "(" ~ arg_list? ~ ")" }
atom        = _{ unary_op? ~ primary ~ (member_access | call_suffix)* }

// Expression structure for Pratt parser
expr = { atom ~ (infix_op ~ atom)* }

// All infix operations that the Pratt parser will handle
infix_op = _{
    add
  | subtract
  | multiply
  | divide
  | modulo
  | power
  | eq
  | ne
  | le
  | ge
  | lt
  | gt
  | logical_and
  | logical_or
  | logical_not
}

unary_minus = { "-" }

unary_op = _{ unary_minus | logical_not }
lvalue   = _{ identifier ~ member_access* }
// Variable and field assignment
assignment = { (lvalue) ~ (assign) ~ expr }

// Print statement with optional arguments
print_stmt = { "print(" ~ print_args? ~ ")" }
print_args = { expr ~ ("," ~ expr)* }

// Control flow
// if_stmt    = { "if" ~ "(" ~ expr ~ ")" ~ block ~ ("else" ~ block)? }
if_stmt    = { "if" ~ "(" ~ expr ~ ")" ~ block ~ ("else" ~ (if_stmt | block))? }
while_stmt = { "while" ~ "(" ~ expr ~ ")" ~ block }
for_stmt   = { "for" ~ "(" ~ (assignment | declaration)? ~ ";" ~ expr? ~ ";" ~ assignment? ~ ")" ~ block }

// Block statements
block = { "{" ~ statement* ~ "}" }

// Expression as statement
expr_stmt   = { expr }
declaration = { "let" ~ identifier ~ (":" ~ type_expr)? ~ assign ~ expr }

// Union of all statement types
statement = _{
    declaration
  | assignment
  | print_stmt
  | if_stmt
  | while_stmt
  | for_stmt
  | return_stmt
  | expr_stmt
}

// Complete program
program = { SOI ~ (statement)* ~ EOI }
